<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TurboBot Web Controller</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        .header h1 {
            color: #4f46e5;
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .header p {
            color: #6b7280;
            font-size: 1.1rem;
        }

        .status-bar {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: rgba(248, 250, 252, 0.6);
            border-radius: 8px;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ef4444;
            animation: pulse 2s infinite;
        }

        .status-dot.connected {
            background: #10b981;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .gas-calculator {
            background: rgba(255, 255, 255, 0.95);
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        .gas-calculator h3 {
            color: #4f46e5;
            margin-bottom: 20px;
            font-size: 1.3rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .gas-info {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 20px;
            margin-bottom: 20px;
        }

        .gas-card {
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            padding: 20px;
            border-radius: 10px;
            border-left: 4px solid #4f46e5;
        }

        .gas-card h4 {
            color: #4f46e5;
            font-size: 1.1rem;
            margin-bottom: 10px;
        }

        .gas-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: #1f2937;
            margin-bottom: 5px;
        }

        .gas-label {
            color: #6b7280;
            font-size: 0.9rem;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .section {
            background: rgba(255, 255, 255, 0.95);
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        .section h3 {
            color: #4f46e5;
            margin-bottom: 20px;
            font-size: 1.3rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .form-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
        }

        .form-group label {
            margin-bottom: 5px;
            font-weight: 500;
            color: #374151;
            font-size: 0.9rem;
        }

        .form-group input, .form-group select {
            padding: 12px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }

        .button-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 12px;
        }

        .btn {
            padding: 12px 16px;
            border: none;
            border-radius: 8px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            text-align: center;
        }

        .btn-primary {
            background: linear-gradient(135deg, #4f46e5, #7c3aed);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(79, 70, 229, 0.3);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #6b7280, #4b5563);
            color: white;
        }

        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(107, 114, 128, 0.3);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
        }

        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(239, 68, 68, 0.3);
        }

        .btn-success {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
        }

        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(16, 185, 129, 0.3);
        }

        .btn-warning {
            background: linear-gradient(135deg, #f59e0b, #d97706);
            color: white;
        }

        .btn-warning:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(245, 158, 11, 0.3);
        }

        .emergency-controls {
            background: rgba(50, 0, 0, 0.8);
            border: 2px solid rgba(0, 0, 0, 0.5);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .emergency-controls h3 {
            color: #dc2626;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .kill-button {
            background: linear-gradient(135deg, #dc2626, #b91c1c);
            color: white;
            padding: 15px 25px;
            font-size: 16px;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 10px;
            width: 100%;
            justify-content: center;
        }

        .kill-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(220, 38, 38, 0.4);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.8);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: #4f46e5;
            margin-bottom: 5px;
        }

        .stat-label {
            color: #6b7280;
            font-size: 0.85rem;
        }

        .terminal {
            background: #1a1a1a;
            color: #00ff00;
            padding: 20px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            height: 400px;
            overflow-y: auto;
            box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.3);
            grid-column: 1 / -1;
        }

        .terminal::-webkit-scrollbar {
            width: 8px;
        }

        .terminal::-webkit-scrollbar-track {
            background: #2a2a2a;
        }

        .terminal::-webkit-scrollbar-thumb {
            background: #4a4a4a;
            border-radius: 4px;
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 2px 0;
        }

        .log-success {
            color: #10b981;
        }

        .log-error {
            color: #ef4444;
        }

        .log-warning {
            color: #f59e0b;
        }

        .log-info {
            color: #3b82f6;
        }

        .loading {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .loading.show {
            display: flex;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #4f46e5;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .alert {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .alert-info {
            background: rgba(59, 130, 246, 0.1);
            color: #1e40af;
            border: 1px solid rgba(59, 130, 246, 0.2);
        }

        .alert-warning {
            background: rgba(245, 158, 11, 0.1);
            color: #92400e;
            border: 1px solid rgba(245, 158, 11, 0.2);
        }

        .alert-danger {
            background: rgba(239, 68, 68, 0.1);
            color: #dc2626;
            border: 1px solid rgba(239, 68, 68, 0.2);
        }

        .full-width {
            grid-column: 1 / -1;
        }

        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .form-grid {
                grid-template-columns: 1fr;
            }
            
            .button-grid {
                grid-template-columns: 1fr;
            }
            
            .gas-info {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🚀 TurboBot Web Controller</h1>
            <p>Enhanced DeFi Automation Tool with Gas Management & V3 Support</p>
        </div>

        <div class="status-bar">
            <div class="status-item">
                <div class="status-dot" id="connectionStatus"></div>
                <span id="connectionText">Disconnected</span>
            </div>
            <div class="status-item">
                <span>🔥 Gas: <strong id="gasPrice">-- Gwei</strong></span>
            </div>
            <div class="status-item">
                <span>💰 ETH: <strong id="ethPrice">$--</strong></span>
            </div>
            <div class="status-item">
                <span>⚡ Active: <strong id="activeOps">0</strong></span>
            </div>
            <div class="status-item">
                <span>👛 Wallets: <strong id="totalWallets">0</strong></span>
            </div>
        </div>

        <div class="gas-calculator">
            <h3>⛽ Gas Cost Calculator</h3>
            <div class="gas-info">
                <div class="gas-card">
                    <h4>Current Gas Price</h4>
                    <div class="gas-value" id="currentGasGwei">-- Gwei</div>
                    <div class="gas-label">Network average</div>
                </div>
                <div class="gas-card">
                    <h4>Average</h4>
                    <div class="gas-value" id="costPerTx">$--</div>
                    <div class="gas-label">21,000 gas limit</div>
                </div>
                <div class="gas-card">
                    <h4>1000 Transfers</h4>
                    <div class="gas-value" id="cost1000Tx">$--</div>
                    <div class="gas-label">Simple transfers</div>
                </div>
                <div class="gas-card">
                    <h4>1000 Swaps</h4>
                    <div class="gas-value" id="cost1000Swaps">$--</div>
                    <div class="gas-label">~200k gas each</div>
                </div>
                <div class="gas-card">
                    <h4>Recommended Gas</h4>
                    <div class="gas-value" id="recommendedGas">-- Gwei</div>
                    <div class="gas-label">For fast confirmation</div>
                </div>
                <div class="gas-card">
                    <h4>Network Status</h4>
                    <div class="gas-value" id="networkStatus">--</div>
                    <div class="gas-label">Congestion level</div>
                </div>
            </div>
        </div>

        <div class="emergency-controls">
            <h3>🚨 Emergency Controls</h3>
            <div class="alert alert-danger">
                <span>⚠️</span>
                <span>Use this button to immediately terminate all running processes and automation.</span>
            </div>
            <button class="kill-button" onclick="killAllProcesses()">
                💀 KILL ALL PROCESSES
            </button>
        </div>

        <div class="main-content">
            <!-- Setup & Configuration -->
            <div class="section">
                <h3>🔧 Setup & Configuration</h3>
                <div class="form-grid">
                    <div class="form-group">
                        <label>RPC URL</label>
                        <input type="text" id="rpcUrl" placeholder="https://base-mainnet.g.alchemy.com/v2/API_KEY">
                    </div>
                    <div class="form-group">
                        <label>Gas Max (ETH)</label>
                        <input type="number" id="gasMax" step="0.000001" placeholder="0.0001">
                    </div>
                </div>
                <div class="button-grid">
                    <button class="btn btn-primary" onclick="executeCommand('setup', [], event.target)">
                        🚀 Run Setup
                    </button>
                    <button class="btn btn-secondary" onclick="executeCommand('update', [], event.target)">
                        📥 Update Scripts
                    </button>
                    <button class="btn btn-secondary" onclick="updateConfig()">
                        💾 Save Config
                    </button>
                </div>
            </div>

            <!-- Wallet Management -->
            <div class="section">
                <h3>👛 Wallet Management</h3>
                <div class="form-grid">
                    <div class="form-group">
                        <label>Create Count</label>
                        <input type="number" id="createCount" placeholder="100" value="100">
                    </div>
                    <div class="form-group">
                        <label>Target Total</label>
                        <input type="number" id="targetCount" placeholder="1000">
                    </div>
                </div>
                <div class="button-grid">
                    <button class="btn btn-primary" onclick="createWallets()">
                        ➕ Create Wallets
                    </button>
                    <button class="btn btn-primary" onclick="targetWallets()">
                        🎯 Create to Target
                    </button>
                    <button class="btn btn-secondary" onclick="checkWallets()">
                        📊 Check Wallets
                    </button>
                </div>
            </div>

            <!-- Airdrop Configuration -->
            <div class="section">
                <h3>💸 Airdrop Configuration</h3>
                <div class="form-grid">
                    <div class="form-group">
                        <label>Chunk Size</label>
                        <input type="number" id="airdropChunk" placeholder="500" value="500">
                    </div>
                    <div class="form-group">
                        <label>Total ETH</label>
                        <input type="number" id="airdropTotal" step="0.001" placeholder="0.1">
                    </div>
                    <div class="form-group">
                        <label>Delay (ms)</label>
                        <input type="number" id="airdropDelay" placeholder="3000" value="3000">
                    </div>
                </div>
                <div class="button-grid">
                    <button class="btn btn-success" onclick="startAirdrop()">
                        💰 Start Airdrop
                    </button>
                </div>
            </div>

            <!-- Trading Operations -->
            <div class="section">
                <h3>⚡ Trading Operations</h3>
                <div class="form-grid">
                    <div class="form-group">
                        <label>Single Token</label>
                        <input type="text" id="singleToken" placeholder="0x...">
                    </div>
                    <div class="form-group">
                        <label>Multi Tokens (comma-separated)</label>
                        <input type="text" id="multiTokens" placeholder="0x...,0x...,0x...">
                    </div>
                    <div class="form-group">
                        <label>Batch Size</label>
                        <input type="number" id="tradeBatchSize" placeholder="50" value="50">
                    </div>
                    <div class="form-group">
                        <label>Start Index</label>
                        <input type="number" id="startIndex" placeholder="0" value="0">
                    </div>
                    <div class="form-group">
                        <label>End Index</label>
                        <input type="number" id="endIndex" placeholder="100" value="100">
                    </div>
                </div>
                <div class="button-grid">
                    <button class="btn btn-primary" onclick="startSwapBatch()">
                        🔄 V2 Swap Batch
                    </button>
                    <button class="btn btn-primary" onclick="startMultiSwapBatch()">
                        🔄 V2 Multi-Swap
                    </button>
                    <button class="btn btn-secondary" onclick="startV3SwapBatch()">
                        ⚡ V3 Swap Batch
                    </button>
                    <button class="btn btn-secondary" onclick="individualSwap()">
                        🔄 V2 Swap Range
                    </button>
                </div>
            </div>

            <!-- Volume Generation -->
            <div class="section">
                <h3>🔥 Volume Generation</h3>
                <div class="form-grid">
                    <div class="form-group">
                        <label>Volume Token</label>
                        <input type="text" id="volumeToken" placeholder="0x...">
                    </div>
                    <div class="form-group">
                        <label>TX Delay (ms)</label>
                        <input type="number" id="volumeTxDelay" placeholder="150" value="150">
                    </div>
                    <div class="form-group">
                        <label>Cycle Delay (ms)</label>
                        <input type="number" id="volumeCycleDelay" placeholder="3000" value="3000">
                    </div>
                    <div class="form-group">
                        <label>Funding Amount</label>
                        <input type="number" id="fundingAmount" step="0.000001" placeholder="0.00001" value="0.00001">
                    </div>
                </div>
                <div class="button-grid">
                    <button class="btn btn-warning" onclick="startVolumeV2()">
                        📈 V2 Volume Bot
                    </button>
                    <button class="btn btn-warning" onclick="startVolumeV3()">
                        📈 V3 Volume Bot
                    </button>
                    <button class="btn btn-warning" onclick="startVolumeV3Fresh()">
                        🆕 V3 Fresh Volume
                    </button>
                </div>
            </div>

            <!-- Automation -->
            <div class="section">
                <h3>🔄 Automation</h3>
                <div class="alert alert-warning">
                    <span>⚠️</span>
                    <span>These operations run continuously until stopped.</span>
                </div>
                <div class="form-grid">
                    <div class="form-group">
                        <label>Cycle Delay (ms)</label>
                        <input type="number" id="cycleDelay" placeholder="2000" value="2000">
                    </div>
                </div>
                <div class="button-grid">
                    <button class="btn btn-success" onclick="startCreateAndSwap()">
                        🆕 Create & V2 Multi-Swap
                    </button>
                    <button class="btn btn-success" onclick="startCreateAndSwapV3()">
                        🆕 Create & V3 Swap
                    </button>
                    <button class="btn btn-success" onclick="startCreateAndMultiSwapV3()">
                        🆕 Create & V3 Multi-Swap
                    </button>
                    <button class="btn btn-danger" onclick="stopAutomation()">
                        🛑 Stop Automation
                    </button>
                </div>
            </div>
        </div>

        <!-- Statistics -->
        <div class="section full-width">
            <h3>📊 Statistics & Monitoring</h3>
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value" id="successfulOps">0</div>
                    <div class="stat-label">Successful Operations</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="failedOps">0</div>
                    <div class="stat-label">Failed Operations</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="totalGasUsed">0.000</div>
                    <div class="stat-label">Total Gas Used (ETH)</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="successRate">0%</div>
                    <div class="stat-label">Success Rate</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="fundedWallets">0</div>
                    <div class="stat-label">Funded Wallets</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="totalBalance">0.000</div>
                    <div class="stat-label">Total ETH Balance</div>
                </div>
            </div>
            <div class="button-grid">
                <button class="btn btn-secondary" onclick="refreshStats()">
                    🔄 Refresh Stats
                </button>
                <button class="btn btn-secondary" onclick="exportLogs()">
                    📥 Export Logs
                </button>
                <button class="btn btn-secondary" onclick="clearTerminal()">
                    🗑️ Clear Terminal
                </button>
            </div>
        </div>
<br />
        <!-- Terminal Output -->
        <div class="section full-width">
            <h3>🖥️ Terminal Output</h3>
            <div class="terminal" id="terminal">
                <div class="log-entry log-info">TurboBot Web Controller v2.0 - Ready</div>
                <div class="log-entry">All controls consolidated into a single clean interface</div>
                <div class="log-entry">─────────────────────────────────────────────</div>
            </div>
        </div>
    </div>

    <!-- Loading Overlay -->
    <div class="loading" id="loading">
        <div class="loading-spinner"></div>
    </div>

    <script>
// Global state management
let automationProcesses = new Set();
let commandHistory = [];
let wsConnection = null;
let activeCommands = new Set();
let stats = {
    successfulOps: 0,
    failedOps: 0,
    totalGasUsed: 0,
    totalWallets: 0,
    fundedWallets: 0,
    totalBalance: 0
};

// Gas price tracking
let gasData = {
    currentPrice: 0,
    ethPrice: 0
};

// WebSocket connection management
function initializeWebSocket() {
    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${protocol}//${window.location.host}`;
    
    try {
        wsConnection = new WebSocket(wsUrl);
        
        wsConnection.onopen = function(event) {
            logToTerminal('🔗 Real-time connection established', 'success');
            updateConnectionStatus(true);
        };
        
        wsConnection.onmessage = function(event) {
            try {
                const message = JSON.parse(event.data);
                handleWebSocketMessage(message);
            } catch (error) {
                console.error('Error parsing WebSocket message:', error);
            }
        };
        
        wsConnection.onclose = function(event) {
            logToTerminal('❌ Real-time connection lost', 'error');
            updateConnectionStatus(false);
            
            setTimeout(() => {
                logToTerminal('🔄 Attempting to reconnect...', 'info');
                initializeWebSocket();
            }, 3000);
        };
        
        wsConnection.onerror = function(error) {
            logToTerminal('⚠️ Connection error occurred', 'warning');
            updateConnectionStatus(false);
        };
        
    } catch (error) {
        logToTerminal('❌ Failed to establish WebSocket connection', 'error');
        updateConnectionStatus(false);
    }
}

// Handle WebSocket messages
function handleWebSocketMessage(message) {
    switch (message.type) {
        case 'connection':
            logToTerminal('✅ Connected to TurboBot backend', 'success');
            break;
            
        case 'output':
            const cleanOutput = message.data.replace(/\n$/, '');
            if (cleanOutput.trim()) {
                logToTerminal(cleanOutput, 'info');
                parseOutputForStats(cleanOutput);
            }
            break;
            
        case 'error':
            logToTerminal(message.data, 'error');
            break;
            
        case 'complete':
            if (message.processId) {
                activeCommands.delete(message.processId);
                setButtonLoadingState(null, false);
            }
            
            if (message.success) {
                logToTerminal(`✅ Command completed: ${message.command}`, 'success');
                stats.successfulOps++;
            } else {
                logToTerminal(`❌ Command failed: ${message.command} (exit code: ${message.exitCode})`, 'error');
                stats.failedOps++;
            }
            updateStats();
            break;
            
        case 'process_error':
            activeCommands.clear();
            setButtonLoadingState(null, false);
            
            logToTerminal(`💥 Process error: ${message.error}`, 'error');
            stats.failedOps++;
            updateStats();
            break;
            
        case 'stopped':
            logToTerminal(`🛑 Process stopped: ${message.command}`, 'warning');
            activeCommands.delete(message.processId);
            setButtonLoadingState(null, false);
            break;
            
        case 'all_stopped':
            logToTerminal(`🛑 All processes stopped (${message.stoppedProcesses?.length || 0} processes)`, 'warning');
            automationProcesses.clear();
            activeCommands.clear();
            setButtonLoadingState(null, false);
            updateStats();
            break;
            
        case 'long_running':
            logToTerminal(`⏳ ${message.message}`, 'info');
            break;
            
        default:
            console.log('Unknown WebSocket message type:', message.type);
    }
}

// Enhanced button loading state management
function setButtonLoadingState(buttonElement, isLoading) {
    if (buttonElement) {
        if (isLoading) {
            buttonElement.classList.add('loading');
            buttonElement.disabled = true;
        } else {
            buttonElement.classList.remove('loading');
            buttonElement.disabled = false;
        }
    } else {
        document.querySelectorAll('.btn').forEach(btn => {
            btn.classList.remove('loading');
            btn.disabled = false;
        });
    }
}

// Enhanced command execution with proper loading management
async function executeCommand(command, args = [], buttonElement = null) {
    const fullCommand = `${command} ${args.join(' ')}`.trim();
    
    const validationResult = validateCommandClient(command, args);
    if (!validationResult.valid) {
        logToTerminal(`❌ Validation failed: ${validationResult.errors.join(', ')}`, 'error');
        return;
    }
    
    logToTerminal(`🚀 Executing: ${fullCommand}`, 'info');
    addToHistory(fullCommand);
    
    if (buttonElement) {
        setButtonLoadingState(buttonElement, true);
    }
    
    try {
        const response = await fetch('/api/execute', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                command: command,
                args: args
            })
        });
        
        const result = await response.json();
        
        if (result.processId) {
            activeCommands.add(result.processId);
        }
        
        if (!result.success) {
            logToTerminal(`❌ Command failed: ${result.error}`, 'error');
            if (result.validationErrors) {
                result.validationErrors.forEach(error => {
                    logToTerminal(`   • ${error}`, 'warning');
                });
            }
            stats.failedOps++;
            updateStats();
            
            if (buttonElement) {
                setButtonLoadingState(buttonElement, false);
            }
        }
        
        if (['volumeV2', 'volumeV3', 'volumeV3Fresh', 'create-and-swap', 'create-and-swapv3', 'create-and-multiswapv3'].includes(command)) {
            automationProcesses.add(result.processId || command);
            logToTerminal(`📊 Added to automation tracking: ${command}`, 'info');
        }
        
    } catch (error) {
        logToTerminal(`🌐 Network error: ${error.message}`, 'error');
        stats.failedOps++;
        updateStats();
        
        if (buttonElement) {
            setButtonLoadingState(buttonElement, false);
        }
    }
}

// Client-side command validation
function validateCommandClient(command, args) {
    const errors = [];
    
    switch (command) {
        case 'volumeV2':
        case 'volumeV3':
            if (args[2] && !isValidEthereumAddress(args[2])) {
                errors.push('Token address must be a valid Ethereum address');
            }
            if (args[3] && (isNaN(args[3]) || parseInt(args[3]) < 50)) {
                errors.push('TX delay must be at least 50 milliseconds');
            }
            break;
            
        case 'create':
            if (args[0] && (isNaN(args[0]) || parseInt(args[0]) < 1 || parseInt(args[0]) > 50000)) {
                errors.push('Wallet count must be between 1 and 50,000');
            }
            break;
    }
    
    return {
        valid: errors.length === 0,
        errors: errors
    };
}

// Validate Ethereum address format
function isValidEthereumAddress(address) {
    return /^0x[a-fA-F0-9]{40}$/.test(address);
}

// KILL ALL PROCESSES - Emergency function
async function killAllProcesses() {
    const button = event.target;
    
    logToTerminal('🚨 EMERGENCY: Killing all processes...', 'error');
    button.disabled = true;
    button.innerHTML = '💀 KILLING...';
    
    try {
        // First try graceful stop
        const response = await fetch('/api/stop-all', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            }
        });
        
        const result = await response.json();
        
        if (result.success) {
            logToTerminal(`✅ ${result.message}`, 'success');
        } else {
            logToTerminal(`❌ Graceful stop failed: ${result.error}`, 'error');
        }
        
        // Force kill attempt
        const killResponse = await fetch('/api/force-kill', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            }
        });
        
        if (killResponse.ok) {
            logToTerminal('💀 Force kill signal sent', 'warning');
        }
        
        // Clear all tracking
        automationProcesses.clear();
        activeCommands.clear();
        document.getElementById('activeOps').textContent = '0';
        
        logToTerminal('🛑 All processes terminated', 'success');
        
    } catch (error) {
        logToTerminal(`🌐 Error during kill operation: ${error.message}`, 'error');
    } finally {
        button.disabled = false;
        button.innerHTML = '💀 KILL ALL PROCESSES';
    }
}

// Gas cost calculator functions
function updateGasCalculator() {
    const gasPrice = gasData.currentPrice; // in Gwei
    const ethPrice = gasData.ethPrice; // in USD


    
    if (gasPrice > 0 && ethPrice > 0) {
        // Gas for micro transaction (21,000 gas)
        const gasCostEth = (gasPrice * 21000) / 1e9; // Convert Gwei to ETH
        const gasCostUsd = gasCostEth * ethPrice;

        console.log(gasData)
        
        // Cost for 1000 transactions
        const cost1000Usd = gasCostUsd * 1000;
        
        // Recommended gas (10% higher than current)
        const recommendedGas = (gasPrice * 1.1).toFixed(2);
        
        document.getElementById('currentGasGwei').textContent = `${gasPrice.toFixed(2)} Gwei`;
        document.getElementById('costPerTx').textContent = `${gasData.costPerMicroTx}$`;
        document.getElementById('cost1000Tx').textContent = `${gasData.costPer1000Tx}$`;
        document.getElementById('cost1000Swaps').textContent = `${gasData.costPer1000SwapTx}$`;
        document.getElementById('recommendedGas').textContent = `${recommendedGas} Gwei`;
        document.getElementById('networkStatus').textContent = `${gasData.networkStatus}`;
        document.getElementById('gasPrice').textContent = `${gasData.currentPrice.toFixed(2)} Gwei`;
    }
}

// Fetch real gas prices from backend API
async function fetchGasPrices() {
    try {
        const response = await fetch('/api/gas-prices');
        if (response.ok) {
            const gasInfo = await response.json();
            
            gasData.ethPrice = gasInfo.ethPriceUSD;
            gasData.currentPrice = gasInfo.currentGasPriceGwei;
            
            // Update additional gas data from backend
            gasData.recommendedPrice = gasInfo.recommendedGasPriceGwei;
            gasData.costPerMicroTx = gasInfo.costPerMicroTxUSD;
            gasData.costPer1000Tx = gasInfo.costPer1000MicroTxUSD;
            gasData.costPer1000SwapTx = gasInfo.costPer1000SwapTxUSD;
            gasData.networkStatus = gasInfo.networkCongestion;
            
            updateGasCalculator();
            
            console.log('Gas prices updated from backend:', {
                gasPrice: `${gasInfo.currentGasPriceGwei} Gwei`,
                ethPrice: `${gasInfo.ethPriceUSD}`,
                cost1000MicroTx: `${gasInfo.costPer1000MicroTxUSD}`,
                cost1000SwapTx: `${gasInfo.costPer1000SwapTxUSD}`,
                congestion: gasInfo.networkCongestion
            });
        } else {
            throw new Error('Backend gas API not available');
        }
        
    } catch (error) {
        console.log('Could not fetch gas prices from backend:', error);
        // Fallback to external API
        try {
            const ethResponse = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=ethereum&vs_currencies=usd');
            const ethData = await ethResponse.json();
            gasData.ethPrice = ethData.ethereum.usd;
            
            // Simulate gas price
            gasData.currentPrice = Math.random() * 30 + 10;
            
            updateGasCalculator();
        } catch (fallbackError) {
            // Use hardcoded fallback values
            gasData.ethPrice = 3500;
            gasData.currentPrice = 20;
            updateGasCalculator();
        }
    }
}

// Enhanced volume generation functions
async function startVolumeV2() {
    const start = document.getElementById('startIndex').value || '0';
    const end = document.getElementById('endIndex').value || '100';
    const token = document.getElementById('volumeToken').value;
    const txDelay = document.getElementById('volumeTxDelay').value || '150';
    const cycleDelay = document.getElementById('volumeCycleDelay').value || '3000';
    
    if (token && !isValidEthereumAddress(token)) {
        logToTerminal('❌ Invalid token address format', 'error');
        return;
    }
    
    const args = [start, end];
    if (token) args.push(token);
    args.push(txDelay, cycleDelay, '1000');
    
    logToTerminal('🔥 Starting V2 volume generation...', 'warning');
    await executeCommand('volumeV2', args, event.target);
}

async function startVolumeV3() {
    const start = document.getElementById('startIndex').value || '0';
    const end = document.getElementById('endIndex').value || '100';
    const token = document.getElementById('volumeToken').value;
    const txDelay = document.getElementById('volumeTxDelay').value || '150';
    const cycleDelay = document.getElementById('volumeCycleDelay').value || '3000';
    
    if (token && !isValidEthereumAddress(token)) {
        logToTerminal('❌ Invalid token address format', 'error');
        return;
    }
    
    const args = [start, end];
    if (token) args.push(token);
    args.push(txDelay, cycleDelay, '1000');
    
    logToTerminal('⚡ Starting V3 volume generation...', 'warning');
    await executeCommand('volumeV3', args, event.target);
}

async function startVolumeV3Fresh() {
    const token = document.getElementById('volumeToken').value;
    const txDelay = document.getElementById('volumeTxDelay').value || '2000';
    const cycleDelay = document.getElementById('volumeCycleDelay').value || '5000';
    const funding = document.getElementById('fundingAmount').value || '0.00001';
    
    if (token && !isValidEthereumAddress(token)) {
        logToTerminal('❌ Invalid token address format', 'error');
        return;
    }
    
    const args = [];
    if (token) args.push(token);
    args.push(txDelay, cycleDelay, funding);
    
    logToTerminal('🆕 Starting V3 fresh wallet volume generation...', 'warning');
    await executeCommand('volumeV3Fresh', args, event.target);
}

// Stop automation
async function stopAutomation() {
    const buttonElement = event.target;
    
    if (automationProcesses.size === 0) {
        logToTerminal('ℹ️ No automation processes running', 'info');
        return;
    }
    
    logToTerminal(`🛑 Stopping ${automationProcesses.size} automation process(es)...`, 'warning');
    setButtonLoadingState(buttonElement, true);
    
    try {
        const response = await fetch('/api/stop-all', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            }
        });
        
        const result = await response.json();
        
        if (result.success) {
            logToTerminal(`✅ ${result.message}`, 'success');
            automationProcesses.clear();
            activeCommands.clear();
            document.getElementById('activeOps').textContent = '0';
        } else {
            logToTerminal(`❌ Failed to stop processes: ${result.error}`, 'error');
        }
        
    } catch (error) {
        logToTerminal(`🌐 Error stopping processes: ${error.message}`, 'error');
    } finally {
        setButtonLoadingState(buttonElement, false);
    }
}

// Wallet management functions
async function createWallets() {
    const count = document.getElementById('createCount').value || '100';
    await executeCommand('create', [count], event.target);
}

async function targetWallets() {
    const target = document.getElementById('targetCount').value;
    if (!target) {
        logToTerminal('Please enter target wallet count', 'warning');
        return;
    }
    await executeCommand('target', [target], event.target);
}

async function checkWallets() {
    await executeCommand('check', [], event.target);
}

async function startAirdrop() {
    const chunk = document.getElementById('airdropChunk').value || '500';
    const total = document.getElementById('airdropTotal').value;
    const delay = document.getElementById('airdropDelay').value || '3000';
    
    const args = [chunk];
    if (total) args.push(total);
    args.push(delay);
    
    await executeCommand('airdrop-batch', args, event.target);
}

// Trading functions
async function startSwapBatch() {
    const batchSize = document.getElementById('tradeBatchSize').value || '50';
    const token = document.getElementById('singleToken').value;
    const delay = '1000';
    
    const args = [batchSize];
    if (token) args.push(token);
    args.push(delay);
    
    await executeCommand('swap-batch', args, event.target);
}

async function startMultiSwapBatch() {
    const batchSize = document.getElementById('tradeBatchSize').value || '50';
    const tokens = document.getElementById('multiTokens').value;
    const delay = '2000';
    
    const args = [batchSize];
    if (tokens) args.push(tokens);
    args.push(delay);
    
    await executeCommand('multiswap-batch', args, event.target);
}

async function startV3SwapBatch() {
    const batchSize = document.getElementById('tradeBatchSize').value || '50';
    const token = document.getElementById('singleToken').value;
    const start = document.getElementById('startIndex').value || '0';
    const end = document.getElementById('endIndex').value || '100';
    const delay = '2000';
    
    await executeCommand('swapv3-batch', [batchSize, token, start, end, delay], event.target);
}

async function individualSwap() {
    const start = document.getElementById('startIndex').value || '0';
    const end = document.getElementById('endIndex').value || '100';
    const token = document.getElementById('singleToken').value;
    
    const args = [start, end];
    if (token) args.push(token);
    
    await executeCommand('swap', args, event.target);
}

// Automation functions
async function startCreateAndSwap() {
    const tokens = document.getElementById('multiTokens').value;
    const cycleDelay = document.getElementById('cycleDelay').value || '2000';
    const fundingAmount = document.getElementById('fundingAmount').value || '0.00001';
    
    const args = [];
    if (tokens) args.push(tokens);
    args.push(cycleDelay, fundingAmount);
    
    logToTerminal('Starting continuous create & swap automation...', 'warning');
    automationProcesses.add('create-and-swap');
    await executeCommand('create-and-swap', args, event.target);
}

async function startCreateAndSwapV3() {
    const tokens = document.getElementById('multiTokens').value;
    const cycleDelay = document.getElementById('cycleDelay').value || '3000';
    const fundingAmount = document.getElementById('fundingAmount').value || '0.000005';
    
    const args = [];
    if (tokens) args.push(tokens);
    args.push(cycleDelay, fundingAmount);
    
    logToTerminal('Starting continuous V3 create & swap automation...', 'warning');
    automationProcesses.add('create-and-swapv3');
    await executeCommand('create-and-swapv3', args, event.target);
}

async function startCreateAndMultiSwapV3() {
    const tokens = document.getElementById('multiTokens').value;
    const cycleDelay = document.getElementById('cycleDelay').value || '3000';
    const fundingAmount = document.getElementById('fundingAmount').value || '0.000005';
    
    const args = [];
    if (tokens) args.push(tokens);
    args.push(cycleDelay, fundingAmount);
    
    logToTerminal('Starting continuous V3 multi-swap automation...', 'warning');
    automationProcesses.add('create-and-multiswapv3');
    await executeCommand('create-and-multiswapv3', args, event.target);
}

// Configuration functions
function updateConfig() {
    const config = {
        rpcUrl: document.getElementById('rpcUrl').value,
        gasMax: document.getElementById('gasMax').value
    };
    
    localStorage.setItem('turbobotConfig', JSON.stringify(config));
    logToTerminal('💾 Configuration updated and saved', 'success');
    logToTerminal(`🌐 RPC URL: ${config.rpcUrl || 'Not set'}`, 'info');
    logToTerminal(`⛽ Gas Max: ${config.gasMax || 'Default'} ETH`, 'info');
}

function loadConfiguration() {
    const savedConfig = localStorage.getItem('turbobotConfig');
    if (savedConfig) {
        try {
            const config = JSON.parse(savedConfig);
            if (config.rpcUrl) document.getElementById('rpcUrl').value = config.rpcUrl;
            if (config.gasMax) document.getElementById('gasMax').value = config.gasMax;
            logToTerminal('📁 Configuration loaded from browser storage', 'info');
        } catch (e) {
            logToTerminal('⚠️ Failed to load saved configuration', 'warning');
        }
    } else {
        document.getElementById('gasMax').value = "0.0001";
    }
}

// Parse server output for statistics updates
function parseOutputForStats(output) {
    try {
        let walletMatch = output.match(/(?:Created|Total|Found|Generated)\s+(\d+)\s+wallets?/i);
        if (walletMatch) {
            const walletCount = parseInt(walletMatch[1]);
            if (walletCount > stats.totalWallets) {
                stats.totalWallets = walletCount;
                updateStats();
            }
        }
        
        walletMatch = output.match(/(\d+)\s+wallets?\s+loaded/i);
        if (walletMatch) {
            const walletCount = parseInt(walletMatch[1]);
            stats.totalWallets = walletCount;
            updateStats();
        }
        
        let fundedMatch = output.match(/(\d+)\s+(?:funded|active)\s+wallets?/i);
        if (fundedMatch) {
            const fundedCount = parseInt(fundedMatch[1]);
            stats.fundedWallets = fundedCount;
            document.getElementById('fundedWallets').textContent = fundedCount;
        }
        
        let balanceMatch = output.match(/Total\s+balance:\s*([\d.]+)\s*ETH/i);
        if (balanceMatch) {
            const totalBalance = parseFloat(balanceMatch[1]);
            stats.totalBalance = totalBalance;
            document.getElementById('totalBalance').textContent = totalBalance.toFixed(6);
        }
        
        let gasMatch = output.match(/Gas\s+used:\s*([\d.]+)\s*ETH/i);
        if (gasMatch) {
            const gasUsed = parseFloat(gasMatch[1]);
            stats.totalGasUsed += gasUsed;
            updateStats();
        }
        
        if (output.match(/✅|✓|SUCCESS|successful/i) && output.match(/transaction|tx|swap/i)) {
            stats.successfulOps++;
            updateStats();
        }
        
        if (output.match(/❌|✗|FAILED|ERROR|failed/i) && output.match(/transaction|tx|swap/i)) {
            stats.failedOps++;
            updateStats();
        }
        
    } catch (error) {
        console.log('Error parsing output for stats:', error);
    }
}

// Update statistics
function updateStats() {
    document.getElementById('totalWallets').textContent = stats.totalWallets;
    document.getElementById('successfulOps').textContent = stats.successfulOps;
    document.getElementById('failedOps').textContent = stats.failedOps;
    document.getElementById('totalGasUsed').textContent = stats.totalGasUsed.toFixed(6);
    
    const total = stats.successfulOps + stats.failedOps;
    const rate = total > 0 ? ((stats.successfulOps / total) * 100).toFixed(1) : 0;
    document.getElementById('successRate').textContent = `${rate}%`;
}

// Terminal logging functions
function logToTerminal(message, type = 'info') {
    const terminal = document.getElementById('terminal');
    const logEntry = document.createElement('div');
    logEntry.className = `log-entry log-${type}`;
    
    const timestamp = new Date().toLocaleTimeString();
    logEntry.innerHTML = `[${timestamp}] ${message}`;
    
    terminal.appendChild(logEntry);
    terminal.scrollTop = terminal.scrollHeight;
}

function clearTerminal() {
    const terminal = document.getElementById('terminal');
    terminal.innerHTML = `
        <div class="log-entry log-info">Terminal cleared - TurboBot Web Controller v2.0</div>
        <div class="log-entry">Ready for new commands</div>
        <div class="log-entry">─────────────────────────────────────────────</div>
    `;
}

// Update connection status
function updateConnectionStatus(connected = false) {
    const statusDot = document.getElementById('connectionStatus');
    const statusText = document.getElementById('connectionText');
    
    if (connected) {
        statusDot.classList.add('connected');
        statusText.textContent = 'Connected';
    } else {
        statusDot.classList.remove('connected');
        statusText.textContent = 'Disconnected';
    }
}

// Add command to history
function addToHistory(command) {
    commandHistory.unshift(command);
    if (commandHistory.length > 50) {
        commandHistory.pop();
    }
}

// Monitoring functions
function refreshStats() {
    logToTerminal('🔄 Refreshing statistics...', 'info');
    executeCommand('check', [], null);
    checkSystemStatus();
    logToTerminal('✅ Statistics refresh initiated', 'success');
}

function exportLogs() {
    const terminal = document.getElementById('terminal');
    const logs = Array.from(terminal.children).map(entry => entry.textContent).join('\n');
    
    const blob = new Blob([logs], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `turbobot-logs-${new Date().toISOString().slice(0, 19)}.txt`;
    a.click();
    URL.revokeObjectURL(url);
    
    logToTerminal('📥 Logs exported successfully', 'success');
}

// System status check
async function checkSystemStatus() {
    try {
        const response = await fetch('/api/status');
        const status = await response.json();
        
        if (!status.scriptExists) {
            logToTerminal('⚠️ script.js not found. Please run setup first.', 'warning');
        }
        
        if (!status.envExists) {
            logToTerminal('⚠️ .env file not found. Please run setup first.', 'warning');
        }
        
        document.getElementById('activeOps').textContent = status.activeProcesses || automationProcesses.size;
        
    } catch (error) {
        console.error('Error checking system status:', error);
    }
}

// Simulate real-time updates
function simulateRealtimeUpdates() {
    // Update gas price display in status bar
    const gasPrice = gasData.currentPrice > 0 ? gasData.currentPrice.toFixed(1) : (Math.random() * 30 + 10).toFixed(1);
    // document.getElementById('gasPrice').textContent = `${gasPrice} Gwei`;
    
    // Update ETH price display
    const ethPrice = gasData.ethPrice > 0 ? gasData.ethPrice.toFixed(0) : (Math.random() * 100 + 3500).toFixed(0);
    document.getElementById('ethPrice').textContent = `${ethPrice}`;
    
    // Update active operations
    document.getElementById('activeOps').textContent = automationProcesses.size;
}

// Initialize the application
function initializeApp() {
    logToTerminal('🚀 TurboBot Web Controller v2.0 initialized', 'success');
    logToTerminal('🔄 Establishing real-time connection...', 'info');
    
    // Initialize WebSocket connection
    initializeWebSocket();
    
    // Load configuration
    loadConfiguration();
    
    // Check system status
    checkSystemStatus();
    
    // Fetch initial gas prices
    fetchGasPrices();
    
    // Start real-time updates
    setInterval(simulateRealtimeUpdates, 5000);
    setInterval(fetchGasPrices, 30000); // Update gas prices every 30 seconds
    
    logToTerminal('💡 All controls consolidated into single interface', 'info');
    logToTerminal('🚨 Emergency kill button available for process termination', 'info');
    logToTerminal('⛽ Gas cost calculator shows micro-transaction costs', 'info');
}

// Initialize when page loads
document.addEventListener('DOMContentLoaded', initializeApp);

// Auto-save configuration on input changes
document.addEventListener('input', function(e) {
    if (e.target.matches('#rpcUrl, #gasMax')) {
        clearTimeout(window.configSaveTimeout);
        window.configSaveTimeout = setTimeout(() => {
            const config = {
                rpcUrl: document.getElementById('rpcUrl').value,
                gasMax: document.getElementById('gasMax').value
            };
            localStorage.setItem('turbobotConfig', JSON.stringify(config));
        }, 1000);
    }
});

// Connection retry logic
function attemptReconnect() {
    if (!wsConnection || wsConnection.readyState === WebSocket.CLOSED) {
        logToTerminal('🔄 Attempting to reconnect...', 'info');
        initializeWebSocket();
    }
}

// Periodic connection check
setInterval(() => {
    if (wsConnection && wsConnection.readyState === WebSocket.OPEN) {
        try {
            wsConnection.send(JSON.stringify({ type: 'ping' }));
        } catch (error) {
            attemptReconnect();
        }
    } else {
        attemptReconnect();
    }
}, 30000);

// Handle page unload
window.addEventListener('beforeunload', function(e) {
    if (automationProcesses.size > 0) {
        fetch('/api/stop-all', { 
            method: 'POST',
            keepalive: true 
        }).catch(err => console.log('Could not stop automation on page unload'));
        
        e.preventDefault();
        e.returnValue = 'You have running automation processes. Are you sure you want to leave?';
        return e.returnValue;
    }
});
    </script>
</body>
</html>